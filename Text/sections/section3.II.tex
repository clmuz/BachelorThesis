%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Итеративная схема}
\label{subsec:cggci}

В подразделе \ref{subsec:ens} описана итеративная схема кластеризации основных групп графа. Адаптивную версию алгоритма также можно итерировать, в таком случае после адаптивного создания промежуточного разбиения на его основе запускается новое адаптивное создание промежуточного множества. Это продолжается до тех пор, пока новое промежуточное разбиение не будет не лучше предыдущего, после чего промежуточное множество передаётся в финальный алгоритм. Такая схема далее называется \emph{итеративная адаптивная схема кластеризации основных групп графа} (\emph{ACGGCi}).

Такой подход не сильно повышает время работы, так как с каждой итерации количество узлов (сообществ) для разбиения уменьшается. Количество узлов или сообществ не может увеличиться или остаться прежним, так как разбиение $P_1$ на основе разбиения $P_2$ имеет не больше сообществ, чем разбиение $P_2$, и в случае, если $P_1$ и $P_2$ имеют одинаковое количество сообществ --- они равны, то есть и их модулярности равны.

\begin{multicols}{2}
\begin{table}[H]
	\caption{Модулярность адаптивной схемы кластеризации основных групп графа и её итеративной версии}
	\label{tab-es-iter-q}
	\begin{tabularx}{\columnwidth}{Xrr}\hline
					& \multicolumn{1}{c}{ACGGC}	& \multicolumn{1}{c}{ACGGCi} \\\hline
	jazz 			& 0.444739	& 0.444871	\\
	\celegans 		& 0.439724	& 0.446973	\\
	netscience 		& 0.907922	& 0.909400	\\
	as-22july06		& 0.671205	& 0.674992	\\
	cond-mat-2003	& 0.743594	& 0.746731	\\
	\hline
	\end{tabularx}
\end{table}
\begin{table}[H]
	\caption{Время работы адаптивной схемы кластеризации основных групп графа и её итеративной версии}
	\label{tab-es-iter-t}
	\begin{tabularx}{\columnwidth}{lrr}\hline
					& \multicolumn{1}{c}{ACGGC}	& \multicolumn{1}{c}{ACGGCi} \\\hline
	jazz 			& 23.68		& 31.51		\\
	\celegans 		& 23.92		& 77.25		\\
	netscience 		& 86.38		& 96.55		\\
	as-22july06		& 2,329		& 5,801		\\
	cond-mat-2003	& 9,371		& 11,654	\\
	\hline
	\end{tabularx}
\end{table}
\end{multicols}

Как видно из таблиц \ref{tab-es-iter-q} и \ref{tab-es-iter-t}, модулярность итеративной схемы каждый раз немного выше, хотя и время работы каждый раз заметно выростало, на некоторых графах в полтора раза, а на других --- более, чем в три.

\begin{figure}[H]
	\begin{tikzpicture}
		\begin{axis}[
			table/col sep = semicolon,
		    height = 0.16\paperheight,
		    width = 0.48\columnwidth,
		    xlabel = {$i$},
		    ylabel = {$Q$},
		    title = {\celegans},
		    cycle list name = diploma list,
		]
		\addplot[mark=*] table [x expr = {\thisrowno{0} + 1}, y = {q}]{data/es/iter/celegans-iterative.csv};
		\end{axis}
	\end{tikzpicture}
	\begin{tikzpicture}
		\begin{axis}[
			table/col sep = semicolon,
		    height = 0.16\paperheight,
		    width = 0.48\columnwidth,
		    xlabel = {$i$},
		    ylabel = {$Q$},
		    title = {cond-mat-2003},
		    cycle list name = diploma list,
		]
		\addplot[mark=*] table [x expr = {\thisrowno{0} + 1}, y = {q}]{data/es/iter/cond-iterative.csv};
		\end{axis}
	\end{tikzpicture}
	\begin{tikzpicture}
		\begin{axis}[
			table/col sep = semicolon,
		    height = 0.16\paperheight,
		    width = \columnwidth,
		    xlabel = {$i$},
		    ylabel = {$Q$},
		    title = {as-22july06},
		    cycle list name = diploma list,
		]
		\addplot[mark=*] table [x expr = {\thisrowno{0} + 1}, y = {q}]{data/es/iter/july-iterative.csv};
		\end{axis}
	\end{tikzpicture}
	\caption{Модулярности промежуточных разбиений в работе \emph{ACGGCi} на трёх графах, $i$ --- номер итерации}
	\label{fig:es-iter}
\end{figure}

Как можно увидеть на рисунке \ref{fig:es-iter}, первое промежуточное разбиение имеет очень небольшую модулярность, а начиная с некоторой итерации модулярность следующего промежуточного разбиения увеличивается очень несильно. Стоит так же заметить, что при $l = 1$, к примеру, модулярность первого промежуточного разбиения была бы выше, так как было бы меньше разбиений, которые участвовали в создании максимального перекрытия разбиений. Но это бы не принесло глобального выигрыша, так как на таком разбиении сложно выделять новые множества. Поэтому небольшая модулярность первого промежуточного разбиения не означает, что оно неудобно для последующей обработки.

Для создания таблиц \ref{tab-es-iter-q} и \ref{tab-es-iter-t} и рисунка \ref{fig:es-iter} использовались следующие параметры \emph{ACGGC} и \emph{ACGGCi}: $d = 2,\ f(Q, k) = -1000 \ln Q,\ \hat{k}_0 = 5,\ l = 6,\ r = 0.05,\ k_{max} = 50$. В качестве финального алгоритма использовался $RG_{10}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{CGGC и ACGGC в качестве финального алгоритма}
\label{subsec:cggc-as-final}

Одно из преимуществ схемы кластеризации основных групп графа заключается в том, что граф с большим количеством вершин преобразуется в небольшой граф, на котором можно выделять сообщества более точными, но и более долгими алгоритмами, используемыми в качестве финальных алгоритмов. Ранее в работе в качестве финальных алгоритмом рассматривался только \emph{RG}. Однако существует вариант использования \emph{ACGGC} с финальным алгоритмом \emph{CGGC} или \emph{ACGGC} с другими параметрами, ровно как и наоборот, использовать \emph{CGGC} с \emph{ACGGC} в качестве финального алгоритма. Это даёт наибольший выигрыш в итеративной схеме кластеризации основных групп графа и её адаптивного аналога, в таком случае одна из версий алгоритма выделяет сообщества в промежуточных разбиениях, пока это возможно. В некоторый момент создание новых промежуточных множеств оказывается неэффективным, однако новые параметры другой версии схемы могут всё ещё быть эффективны.

Так, на графе \emph{\celegans} \emph{ACGGCi} с $RG_{10}$ в качестве финального алгоритма имела модулярность 0.446973 как медиану по 3000 запусков, и работала со средним временем 77.25 миллисекунды. С тем же количеством запусков \emph{CGGCi} с тем же финальным алгоритмом имела модулярность 0.445008 со временем 55.29 миллисекунд. Однако использование \emph{ACGGCi} с \emph{CGGCi} в качестве финального алгоритма дало модулярность 0.447324 со временем 89.96 миллисекунд (в качестве финального алгоритма \emph{CGGCi} при этом использовалось $RG_{10}$). Таким образом, прирост времени по отношению к использованию в качестве финального алгоритма $RG_{10}$ оказался не очень большим, однако такой подход дал ненулевое увеличение модулярности. Использование же \emph{CGGCi} стратегии с \emph{ACGGCi} в качестве финального алгоритма не дало результата на этом графе: модулярность 0.44566 при времени 112.49 миллисекунд.

На рисунке \ref{fig:es-final} изображены модулярности последовательных промежуточных разбиений в \emph{ACGGCi} с \emph{CGGCi} в качестве финального алгоритма. К десятой итерации \emph{ACGGCi} достигло придельного значения, однако после использования на получившемся промежуточном множестве одной итерации \emph{CGGCi} произошёл небольшой глобально, но большой относительно предыдущих изменений скачок модулярности.

\begin{figure}[H]
	\begin{tikzpicture}
		\tikzset{
			% every pin/.style={fill=yellow!50!white,rectangle,rounded corners=3pt,font=\normalsize},
			every pin/.style={fill=black!5!white,rectangle,rounded corners=3pt,font=\normalsize},
			small dot/.style={fill=black,circle,scale=0.3}
		}
		\begin{axis}[
			table/col sep = semicolon,
		    height = 0.25\paperheight,
		    width = \columnwidth,
		    xlabel = {$i$},
		    ylabel = {$Q$},
		    title = {\celegans},
		]
		\addplot[mark = *] table [x expr = {\thisrowno{0} + 1}, y = {q}]{data/es/final/aes.csv};
		\addplot[densely dashed, every mark/.append style={solid}, mark = square*] table [x expr = {\thisrowno{0} + 11}, y = {q}]{data/es/final/es.csv};

		\node[small dot,pin=-90:{начало работы $CGGCi$}] at (axis description cs:0.708,0.905) {};
		\end{axis}
	\end{tikzpicture}
	\caption{Модулярности промежуточных разбиений в работе \emph{ACGGCi} с \emph{CGGCi} в качестве финального алгоритма на графе \emph{\celegans}, $i$ --- номер итерации, сплошная линия --- промежутночные разбиения адаптивной версии, прерывистая обозначает промежуточные разбиения неадаптивной версии}
	\label{fig:es-final}
\end{figure}

В измерениях и на рисунке \ref{fig:es-final} использовались \emph{ACGGCi} с параметрами $d = 2,\ f(Q, k) = -1000 \ln Q,\ \hat{k}_0 = 5,\ l = 6,\ r = 0.05,\ k_{max} = 50$ и \emph{CGGCi} с начальным алгоритмом $RG_{10}$ и параметром $s = 16$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Сравнение ACGGC и CGGC}
\label{subsec:acggc-res}

На таблицах \ref{tab:es-res-q} и \ref{tab:es-res-t} обозначены результаты работы пяти алгоритмов:
\begin{itemize}
	\item $ACGGC$ с параметрами $d = 2,\;f(Q, k) = -1000 \ln Q,\;\hat{k}_0 = 5,\;l = 6,\;r = 0.05,\;k_{max} = 50$, финальным алгоритмом $RG_{10}$, обозначается $ACGGC^I$
	\item $ACGGC$ с параметрами $d = 2,\;f(Q, k) = -1000 \ln Q,\;\hat{k}_0 = 5,\;l = 8,\;r = 0.05,\;k_{max} = 20$, финальным алгоритмом $RG_{10}$, обозначается $ACGGC^{II}$
	\item $CGGC$ с начальным алгоритмом $RG_{10}$, финальным алгоритмом $RG_{10}$ и $s = 16$, обозначается $CGGC_{10}^{10}$
	\item $CGGC$ с начальным алгоритмом $RG_{3}$, финальным алгоритмом $RG_{10}$ и $s = 16$, обозначается $CGGC_{3}^{10}$
	\item $CGGC$ с начальным алгоритмом $RG_{10}$, финальным алгоритмом $RG_{3}$ и $s = 16$, обозначается $CGGC_{10}^{3}$
\end{itemize}

Измерения для $CGGC_3^{10}$ и $CGGC_{10}^3$ на графе \emph{in-2004} не производились из-за большого времени работы.

В таблице \ref{tab:es-res-q} лучшая модулярность на графе обозначалась сплошным подчёркиванием, а вторая по величине --- пунктирным подчёркиванием (если несколько алгоритмов принимали лучшее значение --- все отмечались пукнтирной линией и второе по величине значение никак не отмечалось).

\begin{table}[H]
	\caption{Модулярность разбиений, полученных \emph{ACGGC} и \emph{CGGC} на тестовых графах}
	\label{tab:es-res-q}
	\begin{tabularx}{\textwidth}{XR{1.7cm}R{1.7cm}R{1.7cm}R{1.7cm}R{1.7cm}} \hline
				& $ACGGC^{I}$ & $ACGGC^{II}$ & $CGGC_{10}^{10}$	& $CGGC_{3}^{10}$ & $CGGC_{10}^{3}$ \\ \hline
	karate 			& \dotuline{0.417242} 	& \uline{0.417406} 	& 0.415598 	& 0.396532	& 0.405243	\\
	dolphins		& \uline{0.524109}	& \dotuline{0.523338}	& 0.521399	& 0.523338	& 0.522428	\\
	chesapeake		& \dotuline{0.262439}	& \dotuline{0.262439}	& \dotuline{0.262439}	& \dotuline{0.262439}	& 0.262370	\\
	adjnoun			& \uline{0.299704}	& \dotuline{0.299197}	& 0.295015	& 0.292703	& 0.290638	\\
	polbooks		& \dotuline{0.527237}	& \dotuline{0.527237}	& \dotuline{0.527237}	& 0.526938	& 0.526784	\\
	football		& 0.603324	& \dotuline{0.604266}	& \dotuline{0.604266}	& 0.599537	& 0.599026	\\
	\celegans 		& \uline{0.439604}	& \dotuline{0.438584} 	& 0.435819	& 0.436066	& 0.432261	\\
	jazz			& 0.444739	& \dotuline{0.444848}	& \uline{0.444871} 	& 0.444206 	& 0.444206	\\
	netscience		& \uline{0.907229}	& \dotuline{0.835267}	& 0.724015 	& 0.708812 	& 0.331957	\\
	email			& \dotuline{0.573333}	& \uline{0.573409}	& 0.571018 	& 0.572667 	& 0.567423	\\
	polblogs		& \uline{0.424107} 	& \dotuline{0.423208}	& 0.422901 	& 0.421361 	& 0.390395	\\
	pgpGiantCompo	& \uline{0.883115} 	& \dotuline{0.883085}	& 0.882237 	& 0.882532	& 0.880340	\\
	as-22july06		& \uline{0.671249}	& \dotuline{0.670677}	& 0.666766	& 0.669847	& 0.665260	\\
	cond-mat-2003	& 0.744533 	& \dotuline{0.750367}	& \uline{0.751109} 	& 0.708775	& 0.413719	\\
	caidaRouterLevel& 0.846312	& \dotuline{0.855651}	& 0.851622 	& \uline{0.858955} 	& 0.843835	\\
	cnr-2000		& 0.912762 	& \uline{0.912783}	& 0.912500 	& \dotuline{0.912777}	& 0.912496	\\
	eu-2005			& \uline{0.938292}  & \dotuline{0.936984}	& 0.935510 	& 0.936515	& 0.936420	\\
	in-2004			& \dotuline{0.979844}	& 0.979771	& \uline{0.979883}	& 			& 			\\
	\hline
	\end{tabularx}
\end{table}

В качестве параметра $s$ алгоритма \emph{CGGC} было выбрано значение $s = 16$, так как в \cite{Ovelgoenne&Geyer-Schulz:2012b} отмечалось, что при росте $s$ модулярности приближаются к асимптоте максимального принимаемого алгоритмом значения или держатся на одном уровне. Такое значение будет гарантировать хорошие для \emph{CGGC} модулярности, но не будет гарантировать небольшого времени работы.

В 11 случаях из 18 \emph{ACGGC} с разными параметрами приняло лучшее значение модулярности, чем \emph{CGGC} с разными параметрами, в то же время \emph{CGGC} приняло лучшее значения модулярности, чем \emph{ACGGC} только 4 раза. Алгоритм $ACGGC^{II}$ принимал лучшее или второе по величине значение 17 раз из 18.

Измерения на каждом графе, кроме больших графов \emph{caidaRouterLevel}, \emph{cnr-2000}, \emph{eu-2005}, \emph{in-2004}, запускались более 100 раз для повышения точности.

\begin{table}[H]
	\caption{Время работы \emph{ACGGC} и \emph{CGGC} на тестовых графах}
	\label{tab:es-res-t}
	\begin{tabularx}{\textwidth}{XR{1.7cm}R{1.7cm}R{1.7cm}R{1.7cm}R{1.7cm}} \hline
				& $ACGGC^{I}$ & $ACGGC^{II}$ & $CGGC_{10}^{10}$	& $CGGC_{3}^{10}$ & $CGGC_{10}^{3}$ \\ \hline
	karate 			& 1.045 	& 1.358	 	& 1.381 	& 1.159		& 1.383		\\
	dolphins		& 2.453		& 2.982		& 3.012		& 2.471		& 2.998		\\
	chesapeake		& 1.792		& 2.344		& 2.244		& 1.914		& 2.214		\\
	adjnoun			& 6.193		& 7.627		& 7.411		& 6.342		& 7.571		\\
	polbooks		& 5.064		& 6.310		& 6.136		& 5.166		& 6.135		\\
	football		& 7.157		& 8.441		& 8.638		& 7.439		& 8.547		\\
	\celegans 		& 23.438	& 29.847	& 31.842	& 25.991	& 31.561	\\
	jazz			& 23.306	& 27.546	& 27.580	& 24.268	& 27.508	\\
	netscience		& 84.985	& 61.307	& 60.831	& 40.893	& 59.673	\\
	email			& 71.719	& 91.856	& 94.421	& 80.227	& 94.101	\\
	polblogs		& 173.03	& 174.07	& 177.14	& 123.35	& 178.01	\\
	pgpGiantCompo	& 635.50	& 864.96	& 1,033.56	& 832.90	& 1,030.35	\\
	as-22july06		& 2,330.91	& 3,152.38	& 3,714.06	& 3,071.44	& 3,716.53	\\
	cond-mat-2003	& 9,165.87	& 8,172.36	& 7,485.29	& 3,443.61	& 7,422.58	\\
	caidaRouterLevel& 153,378	& 154,456	& 162,787	& 146,626	& 162,802	\\
	cnr-2000		& 306,539	& 413,869	& 419,965	& 404,296	& 420,604	\\	
	eu-2005			& $2.35\cdot 10^6$	& $3.16\cdot 10^6$	& $3.26\cdot 10^6$	& $3.16\cdot 10^6$ & $3.23\cdot 10^6$ \\
	in-2004			& $6.59\cdot 10^6$	& $8.32\cdot 10^6$	& $8.91\cdot 10^6$	& 			& 			\\
	\hline
	\end{tabularx}
\end{table}

В подразделе \ref{subsec:cggci} была описана итеративная адаптивная схема кластеризации основных групп графа, предполагается, что она даёт лучшие резульаты, чем неитеративная версия за счёт того, что выделяя сообщества в промежуточном разбиении для получения нового промежуточного разбиения, алгоритм повышает качество промежуточного множества. На каждой итерации остаётся всё меньше узлов, относительно которых начальные алгоритмы разошлись во мнении. Необходимо проверить, не исчезает ли в ходе работы итерационной стратегии разница между модулярностями схем \emph{CGGC} и \emph{ACGGC}.

Итеративные схемы \emph{CGGCi} и \emph{ACGGCi} также следует сравнить с использованием \emph{CGGCi} в качестве финального алгоритма для \emph{ACGGCi}, более подробно описанным в подразделе \ref{subsec:cggc-as-final}.

В таблице \ref{tab:esi-res-q} представлены модулярности разбиений, полученных итеративной версией $ACGGC^{I},\ ACGGC^{II}$ и $CGGC_{10}^{10}$, обозначаемые $ACGGCi^{I},\ ACGGCi^{II}$ и $CGGCi$, соответственно. Также в столбце \emph{combined} представлены модулярности $ACGGCi^{I}$ с $CGGCi$ в качестве финального алгоритма. Часто все алгоритмы принимали одно и то же, предположительно максимально возможное, значение. В остальных случаях сплошной линией отмечены лучшая среди четырёх алгоритмов модулярность, достигнутая на графе.

\begin{table}[H]
	\caption{Модулярность работы четырёх итеративных алгоритмов на небольших тестовых графах}
	\label{tab:esi-res-q}
	\begin{tabularx}{\textwidth}{Xrrrr} \hline
					& $ACGGCi^{I}$ & $ACGGCi^{II}$ & $CGGCi$	& combined \\ \hline
	karate			& 0.417242	& \uline{0.417406}	& 0.417242	& 0.417242	\\
	dolphins		& 0.525869	& 0.525869	& 0.525869	& 0.525869	\\
	chesapeake		& 0.262439	& 0.262439	& 0.262439	& 0.262439	\\
	adjnoun			& 0.303731	& 0.303504	& 0.303571	& \uline{0.303970}	\\
	polbooks		& 0.527237	& 0.527237	& 0.527237	& 0.527237	\\
	football		& 0.604266	& 0.604407	& \uline{0.604429}	& 0.604407	\\
	\celegans 		& 0.446964	& 0.446836	& 0.445442	& \uline{0.447234}	\\
	jazz			& 0.444871	& 0.444871	& 0.444871	& 0.444871	\\
	netscience		& \uline{0.908845}	& 0.888422	& 0.725781	& 0.907443	\\
	email			& 0.576778	& 0.577000	& 0.576749	& \uline{0.577110}	\\
	polblogs		& \uline{0.424025}	& 0.422920	& 0.423281	& 0.423996	\\
	\hline
	\end{tabularx}
\end{table}

Заметно, что в итеративные версии схемы примерно равнозначны по результатам, хотя схемы $ACGGC^{I}$ и \emph{combined} дают лучшие результаты чуть чаще, а также их результаты всегда достаточно близко к лучшему результату, в отличии от $CGGCi$.